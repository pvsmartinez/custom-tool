/**
 * Tauri-aware asset store for tldraw.
 *
 * Converts local asset:// URLs (generated by convertFileSrc) to blob:// URLs so
 * tldraw can load images in both the canvas viewport AND in SVG/canvas export
 * contexts (slide previews, AI screenshots). Without this, images stored as
 * asset:// paths fail to render in OffscreenCanvas-based exports because the
 * custom URL scheme is not accessible from that rendering context.
 */
import { readFile } from '../../services/fs';

// Cache persists across multiple opens of the same file (same path → same bytes → same blob URL).
// Call clearAssetBlobCache() when a canvas file is closed to prevent unbounded growth.
const _assetBlobCache = new Map<string, string>();

/**
 * Revoke all cached blob URLs and clear the cache.
 * Call this when a CanvasEditor unmounts to prevent memory leaks.
 */
export function clearAssetBlobCache() {
  for (const blobUrl of _assetBlobCache.values()) {
    try { URL.revokeObjectURL(blobUrl); } catch { /* ignore */ }
  }
  _assetBlobCache.clear();
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const tauriAssetsStore: any = {
  // Native tldraw upload (paste / built-in image tool) → base64 data URL
  upload: async (_asset: unknown, file: File): Promise<{ src: string }> =>
    new Promise<{ src: string }>((res) => {
      const reader = new FileReader();
      reader.onload = () => res({ src: reader.result as string });
      reader.readAsDataURL(file);
    }),

  // Resolve asset src for display + SVG export
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  resolve: async (asset: any): Promise<string | null> => {
    const src: string | undefined = asset?.props?.src;
    if (!src) return null;
    // Local files stored via convertFileSrc — convert to blob URL
    if (src.startsWith('asset://')) {
      const cached = _assetBlobCache.get(src);
      if (cached) return cached;
      try {
        const filePath = decodeURIComponent(new URL(src).pathname);
        const bytes = await readFile(filePath);
        const ext = filePath.split('.').pop()?.toLowerCase() ?? '';
        const MIME: Record<string, string> = {
          png: 'image/png', jpg: 'image/jpeg', jpeg: 'image/jpeg',
          gif: 'image/gif', webp: 'image/webp', svg: 'image/svg+xml',
          avif: 'image/avif', bmp: 'image/bmp', ico: 'image/x-icon',
          tiff: 'image/tiff', tif: 'image/tiff',
        };
        const mimeType = MIME[ext] ?? 'image/png';
        const blobUrl = URL.createObjectURL(new Blob([bytes], { type: mimeType }));
        _assetBlobCache.set(src, blobUrl);
        return blobUrl;
      } catch {
        return src; // fall back to original URL on read error
      }
    }
    // HTTP/HTTPS/data URLs — return as-is
    return src;
  },
};
